const { Octokit } = require("@octokit/rest");
const config = require("../../config");
const { logger, handleError } = require("../utils/helpers");

class GithubService {
  constructor() {
    try {
      this.octokit = new Octokit({
        auth: config.github.personalAccessToken,
        timeZone: "UTC",
        baseUrl: "https://api.github.com",
        retry: {
          enabled: true,
          retries: 3,
        },
      });
      logger.info("GitHub client initialized successfully");
    } catch (error) {
      handleError(error, "Failed to initialize GitHub client");
      throw error;
    }
  }

  async uploadMarkdownFile(fileBuffer, repoName, folder) {
    const [owner, repo] = repoName.split("/");
    const timestamp = new Date().toISOString().split("T")[0];
    const filePath = `${folder}/tweets-${timestamp}-${Date.now()}.md`;
    const base64FileContent = fileBuffer.toString("base64");

    try {
      // Check repository access
      await this.checkRepoAccess(owner, repo);

      // Create or update file
      const response = await this.createOrUpdateFile(
        owner,
        repo,
        filePath,
        base64FileContent
      );

      const fileUrl = `https://github.com/${owner}/${repo}/blob/main/${filePath}`;
      logger.info(`File uploaded successfully to ${fileUrl}`);

      return {
        success: true,
        message: "File uploaded successfully",
        url: fileUrl,
        sha: response.data.content.sha,
      };
    } catch (error) {
      return this.handleGitHubError(error);
    }
  }

  async checkRepoAccess(owner, repo) {
    try {
      await this.octokit.repos.get({ owner, repo });
    } catch (error) {
      if (error.status === 404) {
        throw new Error(`Repository ${owner}/${repo} not found`);
      }
      if (error.status === 403) {
        throw new Error(`No access to repository ${owner}/${repo}`);
      }
      throw error;
    }
  }

  async createOrUpdateFile(owner, repo, filePath, content) {
    try {
      // Try to get existing file
      const existingFile = await this.octokit.repos
        .getContent({
          owner,
          repo,
          path: filePath,
        })
        .catch(() => null);

      const commitMessage = this.generateCommitMessage(filePath);

      return await this.octokit.repos.createOrUpdateFileContents({
        owner,
        repo,
        path: filePath,
        message: commitMessage,
        content: content,
        sha: existingFile?.data?.sha,
        branch: config.github.branch || "main",
      });
    } catch (error) {
      if (error.status === 404) {
        // File doesn't exist, create new
        return await this.octokit.repos.createOrUpdateFileContents({
          owner,
          repo,
          path: filePath,
          message: this.generateCommitMessage(filePath),
          content: content,
          branch: config.github.branch || "main",
        });
      }
      throw error;
    }
  }

  generateCommitMessage(filePath) {
    const timestamp = new Date().toISOString();
    return `📝 Add tweets markdown (${timestamp})

File: ${filePath}
Generated by Twitter-to-GitHub Pipeline`;
  }

  handleGitHubError(error) {
    let errorMessage = "Failed to upload file to GitHub";
    let statusCode = 500;

    switch (error.status) {
      case 401:
        errorMessage = "GitHub authentication failed - check your token";
        statusCode = 401;
        break;
      case 403:
        errorMessage = "No permission to access repository";
        statusCode = 403;
        break;
      case 404:
        errorMessage = "Repository not found";
        statusCode = 404;
        break;
      case 422:
        errorMessage = "Invalid file content or path";
        statusCode = 422;
        break;
      case 429:
        errorMessage = "GitHub API rate limit exceeded";
        statusCode = 429;
        break;
    }

    handleError(error, errorMessage);

    return {
      success: false,
      message: errorMessage,
      status: statusCode,
      error: error.message,
    };
  }

  async checkRateLimit() {
    try {
      const { data } = await this.octokit.rateLimit.get();
      const { remaining, reset } = data.rate;

      logger.info("GitHub API Rate Limit Status:", {
        remaining,
        resetTime: new Date(reset * 1000).toISOString(),
      });

      return {
        remaining,
        resetTime: new Date(reset * 1000),
        isLimited: remaining === 0,
      };
    } catch (error) {
      handleError(error, "Failed to check rate limit");
      return {
        remaining: 0,
        resetTime: new Date(Date.now() + 3600000), // Assume 1 hour
        isLimited: true,
      };
    }
  }

  async createOrUpdateReadme(owner, repo, content) {
    try {
      const path = "README.md";

      // Try to get existing README
      const existing = await this.octokit.repos
        .getContent({
          owner,
          repo,
          path,
        })
        .catch(() => null);

      const response = await this.octokit.repos.createOrUpdateFileContents({
        owner,
        repo,
        path,
        message: "📚 Update README with latest tweets",
        content: Buffer.from(content).toString("base64"),
        sha: existing?.data?.sha,
        branch: config.github.branch || "main",
      });

      logger.info("README updated successfully");
      return {
        success: true,
        url: `https://github.com/${owner}/${repo}/blob/main/README.md`,
        sha: response.data.content.sha,
      };
    } catch (error) {
      handleError(error, "Failed to update README");
      return {
        success: false,
        message: "Failed to update README",
        error: error.message,
      };
    }
  }
}

module.exports = new GithubService();
